;Autores
;Joshua Yarit Amador Lara 
;Mauricio Alberto Chaves Chaves
;Fabiola Rojas Alvarado
;Eddy Villarreal Muñoz principal

;elaboración propuesta por IA(chatgpt) y revisada y levemente modificada por el grupo
;let largoHilera = hilera => {
;    let count = 0;
;
;    while (hilera[count] !== undefined) {
;        count++;
;    }
;    return count;
;}

;function isPalindrome(str, left = 0, right = largoHilera(str) - 1) {
;    // Caso base: si los índices se cruzan, es un palíndromo
;    if (left >= right) {
;        return true;
;    }
;
;    // Si los caracteres en las posiciones izquierda y derecha no coinciden, no es un palíndromo
;    if (str[left] !== str[right]) {
;        return false;
;    }
;
;    // Llamada recursiva, avanzando los índices hacia el centro
;    return isPalindrome(str, left + 1, right - 1);
;}
;
;console.log(isPalindrome("radar"));  // Output: true
;console.log(isPalindrome("hello"));  // Output: false


;elaboración propia
$FUN $1                     ; Definir la función '$1' (largoHilera)
    BLD 0 0                 ; Guardar la dirección de la variable 'hilera' en la pila

    LDV 0                   ; Cargar el valor de la variable 'hilera'
    BST 0 1                 ; Guardar la dirección de la variable 'count' en la pila

    ; Inicio del while

        BLD 0 0             ; Carga 'hilera'
        BLD 0 1             ; Carga 'count'
        STK                 ; Extraer posición count de hilera
        BST 0 2             ; Guardar el valor de la hilera obtenido

        BLD 0 2             ; Cargar el valor de la hilera obtenido
        INO "string"        ; Cargar el valor de la variable 'hilera'
        BF 6                ; Si EQ === false, saltar a BLD 0 0

        ; Inicio body del while

            BLD 0 1             ; Cargar 'count'
            LDV 1               ; Cargar 1
            ADD                 ; Sumar 1 a 'count'
            BST 0 1             ; count = count + 1
            BR -11              ; Volver al inicio del while

        ; Fin body del while

    ; Fin del while

    BLD 0 1                 ; Cargar el valor del argumento 0 0 en la pila

    RET                     ; Retornar el valor de la pila
$END $1                     ; Fin de la definición de la función '$1'
;---------------------------------------------------------------------------------
$FUN $2                     ; Definir la función '$1' (isPalindrome)
    BLD 0 0                 ; Cargar n
    INO "string"            ; Verificar que n sea un número
    BT 3                    ; Si es un número, continua

    LDV "null"              ; Cargar 0
    RET                     ; return 0

    BLD 0 0                 ; parámetro str
    BLD 0 1                 ; parámetro left
    BLD 0 2                 ; parámetro right

    BLD 0 1                 ; left
    BLD 0 2                 ; right
    GTE                     ; left >= right
    BF 3                    ; Si left < right, saltar a la siguiente instrucción
    LDV "true"
    RET                     ; return true

    BLD 0 0                 ; str
    BLD 0 1                 ; left
    STK                     ; Extraer posición left de str
    BST 0 3                 ; Guardar el valor de la hilera obtenido

    BLD 0 0                 ; str
    BLD 0 2                 ; right
    STK                     ; Extraer posición right de str
    BST 0 4                 ; Guardar el valor de la hilera obtenido

    BLD 0 3                 ; Cargar el valor de la hilera obtenido
    BLD 0 4                 ; Cargar el valor de la hilera obtenido
    EQ                      ; str[left] === str[right]
    NOT                     ; str[left] !== str[right]
    BF 3                    ; Si str[left] === str[right], saltar a la siguiente instrucción
    LDV "false"
    RET                     ; return false

    ; Inicio Recursión

    BLD 0 1                 ; left
    LDV 1                   ; Cargar 1
    ADD                     ; left + 1
    BST 0 5                 ; Guardar left + 1

    BLD 0 2                 ; right
    LDV 1                   ; Cargar 1
    SUB                     ; right - 1
    BST 0 6                 ; Guardar right - 1

    BLD 0 0                 ; str
    BLD 0 5                 ; left + 1
    BLD 0 6                 ; right - 1
    LDF $2                  ; Cargar la función '$2'
    APP 3                   ; Llamar a la función '$2' con 3 argumentos
    RET

    ; Fin Recursión
$END $2
;---------------------------------------------------------------------------------
$FUN $0                     ; Definir la función '$0' (main)
    LDV "civic"             ; Cargar el valor de la variable 'hilera'
    BST 0 0                 ; Guardar la dirección de la variable 'str' en la pila
    BLD 0 0                 ; Cargar el valor de la variable 'str'
    LDF $1                  ; Cargar la función '$1'
    APP 1                   ; Llamar a la función '$1' con 0 argumentos
    LDV 1                   ; Cargar el valor retornado por la función '$1'
    SUB 1                   ; restar 1 al valor retornado por la función '$1'
    BST 0 2                 ; Guardar la dirección de la variable 'right' en la pila

    BLD 0 0                 ; Cargar el valor de la variable 'str'
    LDV 0                   ; Cargar el valor de la variable 'left'
    BLD 0 2                 ; Cargar el valor de la variable 'right'

    LDF $2                  ; Cargar la función '$2'
    APP 3                   ; Llamar a la función '$2' con 3 argumentos

    PRN                     ; Imprimir el valor retornado por la función '$1'
    HLT                     ; Parar la ejecución (nunca alcanzará esta instrucción)
$END $0
INI $0