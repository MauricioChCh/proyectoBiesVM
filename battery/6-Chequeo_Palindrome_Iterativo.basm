;Autores
;Joshua Yarit Amador Lara 
;Mauricio Alberto Chaves Chaves
;Fabiola Rojas Alvarado
;Eddy Villarreal Muñoz principal


;elaboración propuesta por IA(chatgpt) y revisada y levemente modificada por el grupo
;let largoHilera = hilera => {
;    let count = 0;
;
;    while (hilera[count] !== undefined) {
;        count++;
;    }
;    return count;
;}

;function isPalindrome(str) {
;    const len = largoHilera(str);
;
;    for (let i = 0; i < len / 2; i++) {
;        if (str[i] !== str[len - 1 - i]) {
;            return false;  // Si hay un desajuste, no es un palíndromo
;        }
;    }
;
;    return true;  // Si no se encontró ningún desajuste, es un palíndromo
;}
;
;console.log(isPalindrome("radar"));  // Output: true
;console.log(isPalindrome("hello"));  // Output: false


;elaboración propia
$FUN $1                     ; Definir la función '$1' (largoHilera)
    BLD 0 0                 ; Guardar la dirección de la variable 'hilera' en la pila

    LDV 0                   ; Cargar el valor de la variable 'hilera'
    BST 0 1                 ; Guardar la dirección de la variable 'count' en la pila

    ; Inicio del while

        BLD 0 0             ; Carga 'hilera'
        BLD 0 1             ; Carga 'count'
        STK                 ; Extraer posición count de hilera
        BST 0 2             ; Guardar el valor de la hilera obtenido

        BLD 0 2             ; Cargar el valor de la hilera obtenido
        INO "string"        ; Cargar el valor de la variable 'hilera'
        BF 6                ; Si EQ === false, saltar a BLD 0 0

        ; Inicio body del while

            BLD 0 1             ; Cargar 'count'
            LDV 1               ; Cargar 1
            ADD                 ; Sumar 1 a 'count'
            BST 0 1             ; count = count + 1
            BR -11              ; Volver al inicio del while

        ; Fin body del while

    ; Fin del while

    BLD 0 1                 ; Cargar el valor del argumento 0 0 en la pila

    RET                     ; Retornar el valor de la pila
$END $1                     ; Fin de la definición de la función '$1'
;-----------------------------------------------------------------------------------------------------------------------
$FUN $2                     ; Definir la función '$1' (isPalindrome)
    BLD 0 0                 ; parámetro str
    INO "string"            ; Verificar que n sea un string
    BT 3                    ; Si es un número, continua
    LDV "null"              ; Cargar 0
    RET                     ; return 0

    BLD 0 0                 ; parámetro str
    LDF $1                  ; Cargar la función '$1'
    APP 1                   ; Llamar a la función '$1' con 1 argumento
    BST 0 3                 ; dirección len = largoHilera(str)
    BLD 0 3

    ; Inicio bucle for

        LDV 0               ; Cargar 0
        BST 0 4             ; 'i'

        BLD 0 4             ; Cargar 'i'
        BLD 0 3             ; Cargar 'len'
        LDV 2               ; Cargar 2
        DIV                 ; Dividir 'len' entre 2
        LT                  ; i < len / 2
        BF 20                ; Si !(i < len / 2), saltar a incremento i++

        ; Inicio body for

            BLD 0 0             ; Cargar 'str'
            BLD 0 4             ; Cargar 'i'
            STK                 ; Extraer posición i de str
            BST 0 5             ; Guardar el valor de str[i] en la pila

            BLD 0 3             ; Cargar 'len'
            LDV 1               ; Cargar 1
            SUB                 ; len - 1
            BLD 0 4             ; Cargar 'i'
            SUB                 ; len - 1 - i
            BST 0 6             ; Guardar el valor de str[len - 1 - i] en la pila

            BLD 0 0             ; Cargar 'str'
            BLD 0 6             ; Cargar str[len - 1 - i]
            STK                 ; Extraer posición str[len - 1 - i] de str
            BST 0 6             ; Guardar el valor de str[len - 1 - i] en la pila

            BLD 0 5             ; Cargar str[i]
            BLD 0 6             ; Cargar str[len - 1 - i]
            EQ                  ; str[i] === str[len - 1 - i]
            BT 3                ; Si EQ === false, saltar a BLD 0 0

            LDV "false"         ; Cargar "False"
            RET                 ; return False

        ; Fin body for

        BLD 0 4             ; Cargar 'i'
        LDV 1               ; Cargar 1
        ADD                 ; i + 1
        BST 0 4             ; i++
        ;BR -20              ; Volver al inicio del bucle for

    ; Fin bucle for

    LDV "true"              ; Cargar "True"
    RET                     ; return True
$END $2                     ; Fin de la definición de la función '$1'
;-----------------------------------------------------------------------------------------------------------------------
$FUN $0
    LDV "eddy"             ; Cargar el valor de la variable 'str'
    LDF $2                  ; Cargar la función '$2'
    APP 1                   ; Llamar a la función '$2' con 1 argumento
    PRN                     ; Imprimir el valor retornado por la función '$2'
    HLT
$END $0
INI $0