;const indiceSubhilera = (hilera, subhilera) => {
;    const maxIndex = hilera.length - subhilera.length;
;
;    for (let i = 0; i <= maxIndex; i++) {
;        let j = 0;
;
;        while (j < subhilera.length && hilera[i + j] === subhilera[j]) {
;            j++;
;        }
;
;        // Si el índice j recorrió toda la subhilera, significa que la encontramos.
;        if (j === subhilera.length) return i;
;    }
;
;    return -1; // Si no se encontró la subhilera
;};
;
;// Ejemplo de uso:
;const hileraPrincipal = "Hola Mundo!";
;const subhileraBuscar = "Mundo";
;console.log(indiceSubhilera(hileraPrincipal, subhileraBuscar)); // Salida: 5


$FUN $1                     ; Definir la función '$1'

    LDV 0                   ; Cargar el valor de la variable 'hilera'
    BST 0 0                 ; Guardar la dirección de la variable 'count' en la pila

    LDV "Hola Mundo!"       ; Cargar el valor de la variable 'hilera'
    BST 0 1                 ; Guardar la dirección de la variable 'hilera' en la pila

    ;Inicio del while
        BLD 0 1             ; Cargar la dirección de la variable 'hilera' en la pila
        BLD 0 0             ; Cargar el valor del argumento 0 0 en la pila (contador)
        STK                 ; Seleccionar el primer elemento de la pila (la dirección de la variable 'hilera')
        BST 0 2             ; Guardar el valor de la hilera obtenido

        BLD 0 0             ; Cargar el valor del argumento 0 0 en la pila (0)
        PLUS 1              ; Sumar 1 al valor del argumento 0 0

        BLD 0 2             ; Cargar el valor del argumento 0 0 en la pila
        LDV ""              ; Cargar el valor vacío, null...
        EQ
        BF -10              ; Si EQ === false, saltar a BLD 0 1
    ;Fin del while

    BLD 0 0                 ; Cargar el valor del argumento 0 0 en la pila
    LDV 1                   ; Cargar el valor de la variable 'count'
    SUB                     ; Restar el valor de la pila

    RET                     ; Retornar el valor de la pila  ;Nota: El código biesVM no está completamente optimizado, pero de la manera optimizada, por algún motivo no me funciona.

$END $1                     ; Fin de la definición de la función '$1'

$FUN $2                     ; Definir la función '$1'

    LDV 0                   ; Cargar el valor de la variable 'hilera'
    BST 0 0                 ; Guardar la dirección de la variable 'count' en la pila

    LDV "Mundo"       ; Cargar el valor de la variable 'hilera'
    BST 0 1                 ; Guardar la dirección de la variable 'hilera' en la pila

    ;Inicio del while
        BLD 0 1             ; Cargar la dirección de la variable 'hilera' en la pila
        BLD 0 0             ; Cargar el valor del argumento 0 0 en la pila (contador)
        STK                 ; Seleccionar el primer elemento de la pila (la dirección de la variable 'hilera')
        BST 0 2             ; Guardar el valor de la hilera obtenido

        BLD 0 0             ; Cargar el valor del argumento 0 0 en la pila (0)
        PLUS 1              ; Sumar 1 al valor del argumento 0 0

        BLD 0 2             ; Cargar el valor del argumento 0 0 en la pila
        LDV ""              ; Cargar el valor vacío, null...
        EQ
        BF -10              ; Si EQ === false, saltar a BLD 0 1
    ;Fin del while

    BLD 0 0                 ; Cargar el valor del argumento 0 0 en la pila
    LDV 1                   ; Cargar el valor de la variable 'count'
    SUB                     ; Restar el valor de la pila

    RET                     ; Retornar el valor de la pila  ;Nota: El código biesVM no está completamente optimizado, pero de la manera optimizada, por algún motivo no me funciona.

$END $2                     ; Fin de la definición de la función '$1'

;---------------------------------------------------------------------------------

$FUN $3
    BLD 0 0         ; Hilera "Hola Mundo!"
    BLD 0 1         ; Subhilera "Mundo"

    BLD 0 2         ; hilera.length
    BLD 0 3         ; hilera.length
    SUB             ; hilera.length - hilera.length
    BST 0 4         ; maxIndex

    ; Inicio bucle for

            LDV 0
            BST 0 5 ;contador

            BLD 0 5 ;contador
            LDV 1
            ADD
            BST 0 5 ;contador = contador + 1

            BLD 0 5
            LDV 4
            LTE
            BT -7

    ; Fin bucle for
    BLD 0 5
    PRN

    RET
$END $3

$FUN $0
    LDF $1
    APP
    BST 0 0     ; Tamaño de "Hola Mundo!"
    LDF $2
    APP
    BST 0 1     ; Tamaño de "Mundo"

    LDV "Hola Mundo!"
    LDV "Mundo"
    BLD 0 0
    BLD 0 1

    LDF $3
    APP 4

    PRN
    HLT
$END $0

INI $0